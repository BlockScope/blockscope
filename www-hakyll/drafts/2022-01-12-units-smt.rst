---
title: Unit Solving with Z3.
subtitle: Worked examples with the encoding from the Thoralf plugin.
tags: haskell, tcplugins
---

Tracing Plugins
---------------

I'd like to get the test suite ``uom-plugin:force`` [#]_ working in full with
the ``thoralf-plugin``.

.. code:: Haskell

    -- test-suite-force/UnitDefs.hs
    module UnitDefs () where

    [u| m, kg, s |]
    [u| N = kg m / s^2 |]

    -- test-suite-force/Tests.hs
    module Main where

    import UnitDefs ()

    myMass = [u| 65 kg |]
    gravityOnEarth = [u| 9.808 m/(s*s) |]
    forceOnGround = gravityOnEarth *: myMass

    main = defaultMain tests

    tests = testGroup "uom-plugin:units"
    [ testGroup "showQuantity"
        [ testCase "myMass"         $ showQuantity myMass         @?= "65.0 kg"
        , testCase "gravityOnEarth" $ showQuantity gravityOnEarth @?= "9.808 m / s^2"
        , testCase "forceOnGround"  $ showQuantity forceOnGround  @?= "637.52 kg m / s^2"
        ]
    ]

Option Tracing
--------------

To help me understand, I'm tracing typechecking by adding the ghc option
``-ddump-tc-trace``.  Compiling this program logged 70,000 lines of tracing, the
unique first words [#]_ of which are:

.. code:: pre

    About addFamInsts addInertCan addInertEq Adding addLocalFamInst addTcEvBind
    alfi Ambiguity Application applyDefaultingRules Bindings can_eq_nc can_pred
    Can't canClass canEqTyVar canEvNC:cls canEvNC:eq canEvNC:irred canonicalize
    check_type checkExpectedKind checkForConflicts checkMain checkSatisfiability
    checkValidInstance checkValidType complete_matches Constraint cvi
    decideKindGeneralisationPlan Decls deeply_instantiate dischargeFmv
    doClsInstErrorChecks Done doTopReact doTopReact/found Eager Emit Emitting
    End end env2 extendFlatCache Filling finish_tuple flatten flatten_many
    flatten/flat-cache floatEqualities Following found Generalisation
    getNoGivenEqs getUnsolvedInerts Got improveTopFunEqs insertInertCan instance
    instantiating Instantiating instCallConstraints kcTyClGroup kcTyClGroup:
    Kick Linking lk1 matchClass matchClassInst matchFamTcM mk_deflt_at_instance
    mkTypeableBinds New newOpenInferExpType newTcEvBinds newWantedEvVar/cache
    Non quantifyZonkedTyVars reactFunEq reportAllUnsolved reportUnsolved
    reportUnsolved(ambig) rewriteEqEvidence rnd runStage setImplicationStatus
    simplifyAmbiguityCheck simplifyTop simplifyUnits Sneaky solveEqualities
    solveImplication solveNestedImplications solveSimple solveSimpleWanteds
    solveWanteds Start Starting Step tc_def tc_hs_type tc_infer_args
    tc_sub_tc_type tc_sub_type_ds Tc10 Tc11 Tc2 Tc3 Tc3b Tc3c Tc4 Tc4a Tc5 Tc6
    Tc7 Tc7a Tc9 tcAddImplicits tcBody tcCheckId tcDeriving tcExtendIdBndrs
    tcFamInstDecl tcFamTyPats tcImplicitTKBndrs tcInferId tcInstDecl2 tcInstMeth
    tcLocalInstDecl tcMatchesFun tcMethodBody tcPluginInit tcPluginSolve
    tcPluginStop tcPolyCheck tcPolyExpr tcPolyExprNC tcSemigroupWarnings
    tcSkolemise tcSpecPrags tcSubType_NC tcSubTypeDS_O tcTyAndCl tcTyFamInstEqn
    tcTyVar2a tcTyVar2b tcWrapResult try_fundeps txExtendKindEnv
    txExtendKindEnvList type u_tys Unfilled unflatten_eq unflattenFmv
    Unflattening unifyTyVar unifyUnits uom-solve updSolvedSetTcs: utype_defer
    VTA writeMetaTyVar zonkSimples

Wrapped Tracing
---------------

To write a plugin we fill in a ``TcPlugin`` with functions.

.. code:: Haskell

    data TcPlugin = forall s. TcPlugin
        { tcPluginInit :: TcPluginM s
        , tcPluginSolve :: s -> TcPluginSolver
        , tcPluginStop :: s -> TcPluginM ()
        }

Here's where we set this up for the ``uom-plugin`` with tracing.

.. code:: Haskell

    import "ghc-tcplugins-extra" GHC.TcPluginM.Extra (tracePlugin)

    -- | The plugin that GHC will load when this module is used with the
    -- @-fplugin@ option.
    plugin :: Plugin
    plugin =
        let theory = mkModuleName "Data.Theory.UoM"
            syntax = mkModuleName "Data.UnitsOfMeasure.Syntax"
            tc = uomSimplifyPlugin theory syntax (fsLit "uom-quantity")
        in
            defaultPlugin
                { tcPlugin = const . Just $ tracePlugin "uom-simplify-plugin" tc
                , pluginRecompile = purePlugin
                }

Calling ``tracePlugin`` wraps the functions we provide with a layer for tracing.

.. code:: Haskell

    -- | Print out extra information about the initialisation, stop, and every run
    -- of the plugin when @-ddump-tc-trace@ is enabled.
    tracePlugin :: String -> TcPlugin -> TcPlugin
    tracePlugin s TcPlugin{..} =
        TcPlugin
            { tcPluginInit = traceInit
            , tcPluginSolve = traceSolve
            , tcPluginStop = traceStop
            }
    where
        traceInit = tcPluginTrace ("tcPluginInit " ++ s) empty >> tcPluginInit
        traceStop z = tcPluginTrace ("tcPluginStop " ++ s) empty >> tcPluginStop z

        traceSolve z given derived wanted = do
            tcPluginTrace
                ("tcPluginSolve start " ++ s)
                (text "given =" <+> ppr given
                $$ text "derived =" <+> ppr derived
                $$ text "wanted =" <+> ppr wanted)

            r <- tcPluginSolve z given derived wanted

            case r of
                TcPluginOk solved new ->
                    tcPluginTrace
                        ("tcPluginSolve ok " ++ s)
                        (text "solved =" <+> ppr solved $$ text "new =" <+> ppr new)
                TcPluginContradiction bad ->
                    tcPluginTrace
                        ("tcPluginSolve contradiction " ++ s)
                        (text "bad =" <+> ppr bad)
            return r

Unit Equations to Solve
-----------------------

Counting the hits for "tcPluginSolve start uom-simplify-plugin", I see the
plugin was called on 16 times to help with typechecking this small program.
Here is the complete set of constraints and unit equations the program needs
solved in order [#]_. I found this sequence twice in the log, we're typechecking
the same thing, once for each module we're compiling.

\\[\
\\begin{align}\
IsCanonical(s)\\\\
1&=\\frac{s}{s}\\\\
IsCanonical(kg)\\\\
1&=\\frac{kg}{kg}\\\\
IsCanonical(m)\\\\
1&=\\frac{m}{m}\\\\
\\frac{kg \\cdot m}{s^2} &= \\frac{m}{s^2} \\cdot kg\\\\
\\end{align}\
\\]

.. code:: pre

    tcPluginSolve start uom-simplify-plugin
    wanted  = [[WD] hole{aaGE} {2}::
                (One :: Unit) ~# ((Base "s" /: Base "s") :: Unit) (CNonCanonical)]

The uom-plugin and the thoralf-plugin can both solve simple single unit
equations.

.. code:: pre

    tcPluginSolve ok uom-simplify-plugin
    solved = [(CO U(plugin:uom-solve, One, Base "s" /: Base "s")_N,
                [WD] hole{aaGE} {2}::
                 (One :: Unit) ~# ((Base "s" /: Base "s") :: Unit) (CNonCanonical))]

.. code:: pre

    tcPluginSolve ok thoralf-uom-plugin
    solved = [(CO U(plugin:thoralf, One, Base "m" /: Base "m")_N,
                [WD] hole{aaJY} {2}:: (One :: Unit)
                                    ~# ((Base "m" /: Base "m") :: Unit) (CNonCanonical))]

A harder unit equation the program needs to typecheck is showing that:

$$\\frac{kg \\cdot m}{s^2} = \\frac{m}{s^2} \\cdot kg$$

.. code:: pre

    tcPluginSolve start uom-simplify-plugin
    wanted  = [[WD] irred_acAG {0}:: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                                  ~~ ((Base "m" /: (Base "s" *: Base "s")) *: Base "kg")
                                  (CNonCanonical),
                [WD] $dIP_acB2 {0}:: ?callStack::CallStack (CDictCan),
                [WD] $dKnownUnit_acB6 {0}::
                        KnownUnit (Unpack (Base "kg")) (CDictCan),
                [WD] $dKnownUnit_acBc {0}::
                        KnownUnit (Unpack (Base "m" /: (Base "s" *: Base "s"))) (CDictCan),
                [WD] $dKnownUnit_acBf {0}::
                        KnownUnit (Unpack ((Base "kg" *: Base "m") /: (Base "s" *: Base "s")))
                        (CDictCan)]

Only the uom-plugin can solve this.

.. code:: pre

    tcPluginSolve ok uom-simplify-plugin
    solved = [(Eq# @[Unit, Unit,
                    (Base "kg" *: Base "m") /: (Base "s" *: Base "s"),
                    (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"]
                    [CO U(plugin:uom-solve
                        , (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
                        , (Base "m" /: (Base "s" *: Base "s")) *: Base "kg")_N]
                    `cast`
                        U(plugin:uom-solve
                        , (((Base "kg" *: Base "m") /: (Base "s" *: Base "s")) :: Unit)
                       ~~ (((Base "m" /: (Base "s" *: Base "s")) *: Base "kg") :: Unit)
                        , ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                       ~~ ((Base "m" /: (Base "s" *: Base "s")) *: Base "kg"))_R,
                [WD] irred_acAG {0}:: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                                   ~~ ((Base "m" /: (Base "s" *: Base "s")) *: Base "kg")
                                   (CNonCanonical))]

Abbreviations
-------------

The solved output is cryptic but there are only a few key strings like ``CO`` to
lookup in GHC source to find out what's being pretty printed.

.. code:: Haskell

    -- OccName.hs
    -- These derived variables have a prefix that no Haskell value could have
    mkDictOcc = mk_simple_deriv varName "$d"

    -- TysPrim.hs
    eqPrimTyConName = mkPrimTc (fsLit "~#") eqPrimTyConKey eqPrimTyCon

    -- TysWiredIn.hs
    heqTyConName =
        mkWiredInTyConName UserSyntax gHC_TYPES (fsLit "~~") heqTyConKey heqTyCon

    heqDataConName =
        mkWiredInDataConName UserSyntax gHC_TYPES (fsLit "Eq#") heqDataConKey heqDataCon

    -- TcEvidence.hs
    instance Outputable EvTerm where
        ppr (EvCast v co) = ppr v <+> (text "`cast`") <+> pprParendCo co
        ppr (EvCoercion co) = text "CO" <+> ppr co

    -- TcMType.hs
    predTypeOccName :: PredType -> OccName
    predTypeOccName ty = case classifyPredType ty of
        ClassPred cls _ -> mkDictOcc (getOccName cls)
        EqPred _ _ _ -> mkVarOccFS (fsLit "cobox")
        IrredPred _ -> mkVarOccFS (fsLit "irred")

    -- TcRnTypes.hs
    instance Outputable Ct where
        ppr ct = ppr (cc_ev ct) <+> parens pp_sort
            where
            pp_sort = case ct of
                CTyEqCan{} -> text "CTyEqCan"
                CFunEqCan{} -> text "CFunEqCan"
                CNonCanonical{} -> text "CNonCanonical"
                CDictCan{cc_pend_sc = pend_sc}
                    | pend_sc -> text "CDictCan(psc)"
                    | otherwise -> text "CDictCan"
                CIrredEvCan{} -> text "CIrredEvCan"
                CHoleCan{cc_hole = hole} -> text "CHoleCan:" <+> ppr (holeOcc hole)

    instance Outputable CtFlavour where
        ppr Given = text "[G]"
        ppr (Wanted WDeriv) = text "[WD]"
        ppr (Wanted WOnly) = text "[W]"
        ppr Derived = text "[D]"

    instance Outputable TcEvDest where
        ppr (HoleDest h)   = text "hole" <> ppr h
        ppr (EvVarDest ev) = ppr ev

    instance Outputable CtEvidence where
        ppr ev = ppr (ctEvFlavour ev)
            <+> pp_ev
            <+> braces (ppr (ctl_depth (ctEvLoc ev))) <> dcolon
            <+> ppr (ctEvPred ev)
            where
            pp_ev = case ev of
                CtGiven{ctev_evar = v} -> ppr v
                CtWanted{ctev_dest = d} -> ppr d
                CtDerived{} -> text "_"

So we can say that:

``CO``
    is evidence of coercion.

``~#``
    is primitive type constructor equality.

``Eq#``
    is data constructor equality.

``~~``
    is type constructor equality.

``cast``
    is evidence of a cast.

``[WD]``
    are wanted and derived constraints.

``cobox``
    is an equality predicate.

``irred``
    is an irreducible predicate.

``CDictCan``
    is a typeclass canonical constraint.

``CNonCanonical``
    is a non-canonical constraint.

``{_}::``
    the sub-goal depth to prevent constraint solver looping.

I'm pretty sure that the ``_N`` and ``_R`` indicate equivalence as nominal or
representational. A ``$d`` prefix, like ``$dKnownUnit``, is a type class.
Re-reading the first simple wanted; it is a wanted and derived type hole, the
subgoal depth is 2 and we're seeking a non-canonical constraint equating
primitives.

.. code:: pre

    wanted  = [[WD] hole{aaGE} {2}::
                (One :: Unit) ~# ((Base "s" /: Base "s") :: Unit) (CNonCanonical)]

Unwrapped Tracing
-----------------

This plugin also does its own tracing with calls to ``tcPluginTrace`` such as
when it is unifying normalized units.

.. code:: Haskell

    -- | An atom in the normal form is either a base unit, a variable or a
    -- stuck type family application (but not one of the built-in type
    -- families that correspond to group operations).
    data Atom = BaseAtom Type | VarAtom TyVar | FamAtom TyCon [Type]

    -- | A unit normal form is a signed multiset of atoms; we maintain the
    -- invariant that the map does not contain any zero values.
    newtype NormUnit = NormUnit{_NormUnit :: Map.Map Atom Integer} deriving Eq

    data UnitEquality = UnitEquality Ct NormUnit NormUnit

    -- | Attempt to unify two normalised units to produce a unifying
    -- substitution.  The 'Ct' is the equality between the non-normalised (and
    -- perhaps less substituted) unit type expressions.
    unifyUnits :: UnitDefs -> UnitEquality -> TcPluginM UnifyResult
    unifyUnits uds (UnitEquality ct u0 v0) = do
        tcPluginTrace "unifyUnits" (ppr u0 $$ ppr v0)
        unifyOne uds ct [] [] [] (u0 /: v0)

.. code:: pre

    unifyUnits
        [("kg", [1]), ("m", [1]), ("s", [-, 2])]
        [("kg", [1]), ("m", [1]), ("s", [-, 2])]

Tracing in IO
-------------

It is good to be able to see the conversation the ``thoralf-plugin`` has with
the SMT solver. The code for `the Thoralf plugin paper`_ used ``tcPluginIO`` to
write to stout with ``putStrLn``. I find that useful too as I can pick just what
I want to trace uninterrupted by copious other tracing. I have a small package
for doing this, `ghc-tcplugins-trace`_.

.. code:: Haskell

    data DebugCt 
        DebugCt 
            { traceCallCount :: TraceCallCount
            -- ^ Trace TcPlugin call count.
            , traceCts :: TraceCts
            -- ^ Trace GHC constraints.
            , traceCarry :: TraceCarry
            -- ^ Trace GHC constraints carried through conversion and solving.
            , traceSolution :: TraceSolution
            -- ^ Trace the solution, the @TcPluginResult@.
            }

I'm using this with both plugins and have another for tracing SMT conversion and
conversation.

.. code:: Haskell

    data DebugSmt =
        DebugSmt
            { traceConvertCtsToSmt :: TraceConvertCtsToSmt
            -- ^ Trace conversions to SMT notation
            , traceSmtConversation :: TraceSmtConversation
            -- ^ Trace the conversation with the SMT solver
            }

.. [#] I've removed pragmas, most imports and type signatures from the program listing.
.. [#]
    With a regex I grabbed the first word ``s/^(\S+).*$/$1/``, deleted lines with
    leading spaces with ``s/ .*\n/\n/`` and deleted multiple blank lines with
    ``s/\n\n+/\n/``.
.. [#] Not shown are calls to the plugin want to solve constraints for ``?callStack``.
.. _`the Thoralf plugin paper`: https://richarde.dev/papers/2018/thoralf/thoralf.pdf
.. _ghc-tcplugins-trace: https://github.com/BlockScope/ghc-tcplugins-trace