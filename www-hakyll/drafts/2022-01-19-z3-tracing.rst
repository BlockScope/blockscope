---
title: Z3 Tracing
subtitle: Improving tracing of the Thoralf plugin.
tags: haskell, tcplugins, z3, tracing
---

The thoralf plugin is using simple-smt_ to talk with Z3 to solve typechecking
constraints. The communication format are smt-lib_ s-expressions. This package
is able to read and show these without needing to know much about them. It does
recognize a few of these s-expressions from the smt-lib standard. The recursive
data representation of these is simple, hence the name I guess.

.. code:: haskell

    data SExpr = Atom String | List [SExpr]

Removing Extra Spaces
---------------------

I've been doing a lot of tracing and noticed extra spaces in the s-expressions.

.. code:: pre

    > cabal build thoralf-plugin-uom:uom-diy > thoralf-uom-diy.txt

.. code:: smt2

    ; thoralf-uom-diy.txt
    (assert (= a1Cv a1Cn ) )
    (check-sat )

I'd like to have the s-expressions show up in the trace without those extra
spaces, like this:

.. code:: smt2

    (assert (= a1Cv a1Cn))
    (check-sat)

This the fix for that.

.. code:: diff

     --- SimpleSMT.hs
     +++ SimpleSMT.hs
        showsSExpr :: SExpr -> ShowS
        showsSExpr ex =
          case ex of
            Atom x  -> showString x
    -       List es -> showChar '(' .
    -                   foldr (\e m -> showsSExpr e . showChar ' ' . m)
    -                   (showChar ')') es
    +       List [] -> showString "()"
    +       List (e0 : es) -> showChar '(' . showsSExpr e0 .
    +                          foldr (\e m -> showChar ' ' . showsSExpr e . m)
    +                          (showChar ')') es

Choosing a S-Expression Printer
-------------------------------

Functions in simple-smt for showing s-expressions are ``showsSExpr`` and
``ppSExpr``.

.. code:: haskell

    -- | Show an s-expression.
    --
    -- >>> let Just (e, _) = readSExpr "(assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))"
    -- >>> putStrLn $ showsSExpr e ""
    -- (assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))
    showsSExpr :: SExpr -> ShowS

    -- | Show an s-expression in a somewhat readable fashion.
    --
    -- >>> let Just (e, _) = readSExpr "(assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))"
    -- >>> putStrLn $ ppSExpr e ""
    -- (assert
    --    (=
    --       (
    --         (_
    --            map
    --            (-
    --               (Int Int)
    --               Int))
    --         a1Cl
    --         a1Cm)
    --       a1Cv))
    ppSExpr :: SExpr -> ShowS

I want to use the pretty printer ``ppSExpr`` but simple-smt itself uses the
all-in-one-line printer ``showsSExpr`` and that is how the comms with Z3 are
showing up while I'm tracing. To work on this I added simple-smt as a submodule
after first forking it to the *BlockScope* organization on github.

.. code:: pre

    > git submodule add https://github.com/BlockScope/simple-smt
    > cd simple-smt
    > git checkout -b wip/plugins-for-blobs

I need to add an entry to ``cabal.project`` to pick up this dependency locally
rather than from hackage, all without changing any of the ``*.cabal`` files that
mention ``simple-smt`` as a dependency.

.. code:: haskell

    -- cabal.project
    packages:
        simple-smt
        thoralf-plugin

By passing an ``SExpr -> ShowsS`` printer in as a parameter when setting up the
solver and using this instead of ``showsSExpr`` I'm now getting nicely formatted
and much easier to follow tracing. As a bonus, lines are all short enough so hat
they won't need scrolling when viewed in a narrow frame so as when showing up as
code snippets on this blog.

.. code:: haskell

    -- | Start a new solver process.
    newSolver
        :: String -- ^ Executable
        -> [String] -- ^ Arguments
        -> (SExpr -> ShowS) -- ^ Function for showing s-expressions
        -> Maybe Logger -- ^ Optional logging here
        -> IO Solver

.. _simple-smt: https://hackage.haskell.org/package/simple-smt
.. _smt-lib: https://smtlib.cs.uiowa.edu/language.shtml