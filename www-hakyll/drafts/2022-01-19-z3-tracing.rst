---
title: Z3 Tracing
subtitle: Improving tracing of the Thoralf plugin.
tags: haskell, tcplugins, z3, tracing
---

The thoralf plugin is using simple-smt_ to talk with Z3 to solve typechecking
constraints. The communication format are smt-lib_ s-expressions. This package
is able to read and show these without needing to know much about them. It does
recognize a few of these s-expressions from the smt-lib standard. The recursive
data representation of these is simple, hence the name I guess.

.. code:: haskell

    data SExpr = Atom String | List [SExpr]

Removing Extra Spaces
---------------------

I've been doing a lot of tracing and noticed extra spaces in the s-expressions.

.. code:: pre

    > cabal build thoralf-plugin-uom:uom-diy > thoralf-uom-diy.txt

.. code:: smt2

    ; thoralf-uom-diy.txt
    (assert (= a1Cv a1Cn ) )
    (check-sat )

I'd like to have the s-expressions show up in the trace without those extra
spaces, like this:

.. code:: smt2

    (assert (= a1Cv a1Cn))
    (check-sat)

This the fix for that.

.. code:: diff

     --- SimpleSMT.hs
     +++ SimpleSMT.hs
        showsSExpr :: SExpr -> ShowS
        showsSExpr ex =
          case ex of
            Atom x  -> showString x
    -       List es -> showChar '(' .
    -                   foldr (\e m -> showsSExpr e . showChar ' ' . m)
    -                   (showChar ')') es
    +       List [] -> showString "()"
    +       List (e0 : es) -> showChar '(' . showsSExpr e0 .
    +                          foldr (\e m -> showChar ' ' . showsSExpr e . m)
    +                          (showChar ')') es

Choosing a S-Expression Printer
-------------------------------

Functions in simple-smt for showing s-expressions are ``showsSExpr`` and
``ppSExpr``.

.. code:: haskell

    -- | Show an s-expression.
    --
    -- >>> let Just (e, _) = readSExpr "(assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))"
    -- >>> putStrLn $ showsSExpr e ""
    -- (assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))
    showsSExpr :: SExpr -> ShowS

    -- | Show an s-expression in a somewhat readable fashion.
    --
    -- >>> let Just (e, _) = readSExpr "(assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))"
    -- >>> putStrLn $ ppSExpr e ""
    -- (assert
    --    (=
    --       (
    --         (_
    --            map
    --            (-
    --               (Int Int)
    --               Int))
    --         a1Cl
    --         a1Cm)
    --       a1Cv))
    ppSExpr :: SExpr -> ShowS

I want to use the pretty printer ``ppSExpr`` but simple-smt itself uses the
all-in-one-line printer ``showsSExpr`` and that is how the comms with Z3 are
showing up while I'm tracing. To work on this I added simple-smt as a submodule
after first forking it to the *BlockScope* organization on github.

.. code:: pre

    > git submodule add https://github.com/BlockScope/simple-smt
    > cd simple-smt
    > git checkout -b wip/plugins-for-blobs

I need to add an entry to ``cabal.project`` to pick up this dependency locally
rather than from hackage, all without changing any of the ``*.cabal`` files that
mention ``simple-smt`` as a dependency.

.. code:: haskell

    -- cabal.project
    packages:
        simple-smt
        thoralf-plugin

By passing an ``SExpr -> ShowsS`` printer in as a parameter when setting up the
solver and using this instead of ``showsSExpr`` I'm now getting nicely formatted
and much easier to follow tracing. As a bonus, lines are all short enough so hat
they won't need scrolling when viewed in a narrow frame so as when showing up as
code snippets on this blog.

.. code:: haskell

    -- | Start a new solver process.
    newSolver
        :: String -- ^ Executable
        -> [String] -- ^ Arguments
        -> (SExpr -> ShowS) -- ^ Function for showing s-expressions
        -> Maybe Logger -- ^ Optional logging here
        -> IO Solver

Roundtripping
-------------

I'd like to be able to take the output of tracing compilation of a package with
modules using the thoralf plugin and then to take that output and use it as
input to the Z3 solver as-is.

The logging of simple-smt prefixes comms with ``[send->]`` and ``[<-recv]``. I'm
able to filter that out before tracing by updating the logger to strip out those
prefixes.

.. code:: haskell

    data DebugSmtTalk =
        DebugSmtTalk
            { traceSend :: Bool
            , traceRecv :: DebugSmtRecv
            , traceErr :: Bool
            , traceOther :: Bool
            , traceArrow :: Bool
            , traceCtsComments :: Bool
            }

    data DebugSmtRecv
        = DebugSmtRecvAll Bool
        | DebugSmtRecvSome
            { traceSuccess :: Bool
            , traceCheckSat :: Bool
            }
        deriving Eq

    -- | Flag for controlling the two-way conversation with the SMT solver.
    newtype TraceSmtTalk = TraceSmtTalk DebugSmtTalk

    -- TODO: Contribute upstream to SimpleSMT to avoid matching on string prefixes.
    solverWithLevel :: TraceSmtTalk -> IO SMT.Solver
    solverWithLevel (TraceSmtTalk dbg)
        | isSilencedTalk dbg = grabSMTsolver Nothing
        | otherwise = do
            logger@Logger{logMessage = logMsg} <- SMT.newLogger 0
            let logger' = logger{logMessage = \s -> do
                let sends = split (dropBlanks $ onSublist "[send->] ") s
                let recvs = split (dropBlanks $ onSublist "[<-recv] ") s
                let errs = split (dropBlanks $ onSublist "[stderr] ") s

                let dbgArrow = traceArrow dbg
                let dbgSend = traceSend dbg

                let dbgRecvCheckSat =
                        case traceRecv dbg of
                            DebugSmtRecvSome{traceCheckSat = b} -> b
                            _ -> False

                let dbgRecvSuccess =
                        case traceRecv dbg of
                            DebugSmtRecvSome{traceSuccess = b} -> b
                            _ -> False

                let dbgRecvAll = DebugSmtRecvAll True == traceRecv dbg

                case (recvs, sends, errs) of
                    (_, "[send->] " : [msg], _) ->
                        if | dbgSend && dbgArrow -> logMsg s
                           | dbgSend -> logMsg msg
                           | otherwise -> return ()

                    -- NOTE: :print-success can print success | unsupported | error _.
                    ("[<-recv] " : msgContent, _, _) ->
                        case msgContent of
                            [msg@"sat"] ->
                                if | dbgRecvCheckSat && dbgArrow -> logMsg s
                                   | dbgRecvCheckSat -> logMsg msg
                                   | otherwise -> return ()

                            [msg@"unsat"] ->
                                if | dbgRecvCheckSat && dbgArrow -> logMsg s
                                   | dbgRecvCheckSat -> logMsg msg
                                   | otherwise -> return ()

                            [msg@"success"] ->
                                if | dbgRecvSuccess && dbgArrow -> logMsg s
                                   | dbgRecvSuccess -> logMsg msg
                                   | otherwise -> return ()

                            [msg@"unsupported"] ->
                                if | dbgRecvSuccess && dbgArrow -> logMsg s
                                   | dbgRecvSuccess -> logMsg msg
                                   | otherwise -> return ()

                            "error" : _ ->
                                if | dbgRecvSuccess && dbgArrow -> logMsg s
                                   | dbgRecvSuccess -> logMsg $ drop (length "[<-recv] error ") s
                                   | otherwise -> return ()

                            _msgs ->
                                if | dbgRecvAll && dbgArrow -> logMsg s
                                   | dbgRecvAll -> logMsg s
                                   | otherwise -> return ()

                    (_, _, "[stderr] " : _) ->
                        when (traceErr dbg) $ logMsg s

                    (_, _, _) ->
                        when (traceOther dbg) $ logMsg s
                }

            grabSMTsolver (Just logger')

    grabSMTsolver :: Maybe SMT.Logger -> IO SMT.Solver
    grabSMTsolver =
        -- NOTE: IfÂ you don't want the s-expressions pretty printed then substitute
        -- SMT.showsSExpr for SMT.ppSExpr.
        SMT.newSolver "z3" ["-smt2", "-in"] SMT.ppSExpr

What's left to do for roundtripping is prefix any output that I don't want as
input with ``;`` to make it a comment.

Constraints Encoding
--------------------

The whole point of the thoralf plugin is to encode a theory as s-expressions so
that it can offload solving to Z3. When tracing I'd like to see the constraints
passed in to the plugin by GHC. I've found two ways of showing these, printed
with GHC's own pretty printing and with printing included with the plugin
itself. I've gone through the following trace output and added ``:named``
assertions. To help me work in interactive mode with z3, I've added a lot of
options and commented out push, pop and exit commands.

.. code:: smt2

    (set-option :global-declarations true)
    (set-option :interactive-mode true)
    (set-option :print-success true)
    (set-option :produce-assertions true)
    (set-option :produce-assignments true)
    (set-option :produce-models true)
    (set-option :produce-proofs true)
    (set-option :produce-unsat-assumptions true)
    (set-option :produce-unsat-cores true)
    ; (push 1)
    ; (exit)
    (declare-datatypes () ((Type (apply (fst Type) (snd Type)) (lit (getstr String)))))
    (declare-const one Int)
    (assert (! (= one 1) :named one=1))
    (declare-const base (Array String Int))
    (declare-const enc (Array String Int))
    (declare-const exp (Array String Int))
    (assert (! (= enc base) :named enc=base))
    ; (push 1)

    ; GIVENS (GHC style)
    ; [G] cobox_a1Bz {3}:: One ~ fsk0 (CFunEqCan)
    ; [G] cobox_a1Bx {2}:: Base "m" ~ fsk0 (CFunEqCan)
    ; [G] cobox_a1BD {2}:: Base "s" ~ fsk0 (CFunEqCan)
    ; [G] cobox_a1BB {2}:: (fsk0 *: fsk1) ~ fsk2 (CFunEqCan)
    ; [G] cobox_a1BF {2}:: (fsk0 *: fsk1) ~ fsk2 (CFunEqCan)
    ; [G] cobox_a1BH {1}:: (fsk0 /: fsk1) ~ fsk2 (CFunEqCan)
    ; [G] cobox_a1BL {1}:: fsk0 ~ mps (CTyEqCan)

    ; WANTEDS (GHC style)
    ; []

    ; GIVENS (Thoralf style)
    ; (One [],a1By)
    ; (Base ["m"],a1Bw)
    ; (Base ["s"],a1BC)
    ; (*: [a1Bw,a1By],a1BA)
    ; (*: [a1BC,a1By],a1BE)
    ; (/: [a1BA,a1BE],a1BG)
    ; (a1BG,a1u1)

    ; WANTEDS (Thoralf style)
    ; []

    ; (push 1)
    (declare-const a1u1 (Array String Int))
    (declare-const a1Bw (Array String Int))
    (declare-const a1By (Array String Int))
    (declare-const a1BA (Array String Int))
    (declare-const a1BC (Array String Int))
    (declare-const a1BE (Array String Int))
    (declare-const a1BG (Array String Int))
    (assert
        (! (= ((as const (Array String Int)) 0) a1By) :named a1By=1))
    (assert
        (! (= (store base "m" one) a1Bw) :named a1Bw=m))
    (assert
        (! (= (store base "s" one) a1BC) :named a1BC=s))
    (assert
        (! (= (
            (_
                map
                (+
                    (Int Int)
                    Int))
            a1Bw
            a1By) a1BA) :named a1BA=a1Bw*a1By))
    (assert
        (! (= (
            (_
                map
                (+
                    (Int Int)
                    Int))
            a1BC
            a1By) a1BE) :named a1BE=a1BC*a1By))
    (assert
        (! (= (
            (_
                map
                (-
                    (Int Int)
                    Int))
            a1BA
            a1BE) a1BG) :named a1BG=a1BA/a1BE))
    (assert
    (= a1BG a1u1))
    (echo "checkpoint #1")
    (check-sat)
    ; sat

.. _simple-smt: https://hackage.haskell.org/package/simple-smt
.. _smt-lib: https://smtlib.cs.uiowa.edu/language.shtml