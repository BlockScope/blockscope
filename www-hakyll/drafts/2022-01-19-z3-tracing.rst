---
title: Z3 Tracing
subtitle: Improving tracing of the Thoralf plugin.
tags: haskell, tcplugins, z3, tracing
---

The thoralf plugin is using simple-smt_ to talk with Z3 to solve typechecking
constraints. The communication format are smt-lib_ s-expressions. This package
is able to read and show these without needing to know much about them. It does
recognize a few of these s-expressions from the smt-lib standard. The recursive
data representation of these is simple, hence the name I guess.

.. code:: haskell

    data SExpr = Atom String | List [SExpr]

Removing Extra Spaces
---------------------

I've been doing a lot of tracing and noticed extra spaces in the s-expressions.

.. code:: pre

    > cabal build thoralf-plugin-uom:uom-diy > thoralf-uom-diy.txt

.. code:: smt2

    ; thoralf-uom-diy.txt
    (assert (= a1Cv a1Cn ) )
    (check-sat )

I'd like to have the s-expressions show up in the trace without those extra
spaces, like this:

.. code:: smt2

    (assert (= a1Cv a1Cn))
    (check-sat)

This the fix for that.

.. code:: diff

     --- SimpleSMT.hs
     +++ SimpleSMT.hs
        showsSExpr :: SExpr -> ShowS
        showsSExpr ex =
          case ex of
            Atom x  -> showString x
    -       List es -> showChar '(' .
    -                   foldr (\e m -> showsSExpr e . showChar ' ' . m)
    -                   (showChar ')') es
    +       List [] -> showString "()"
    +       List (e0 : es) -> showChar '(' . showsSExpr e0 .
    +                          foldr (\e m -> showChar ' ' . showsSExpr e . m)
    +                          (showChar ')') es

Choosing a S-Expression Printer
-------------------------------

Functions in simple-smt for showing s-expressions are ``showsSExpr`` and
``ppSExpr``.

.. code:: haskell

    -- | Show an s-expression.
    --
    -- >>> let Just (e, _) = readSExpr "(assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))"
    -- >>> putStrLn $ showsSExpr e ""
    -- (assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))
    showsSExpr :: SExpr -> ShowS

    -- | Show an s-expression in a somewhat readable fashion.
    --
    -- >>> let Just (e, _) = readSExpr "(assert (= ((_ map (- (Int Int) Int)) a1Cl a1Cm) a1Cv))"
    -- >>> putStrLn $ ppSExpr e ""
    -- (assert
    --    (=
    --       (
    --         (_
    --            map
    --            (-
    --               (Int Int)
    --               Int))
    --         a1Cl
    --         a1Cm)
    --       a1Cv))
    ppSExpr :: SExpr -> ShowS

I want to use the pretty printer ``ppSExpr`` but simple-smt itself uses the
all-in-one-line printer ``showsSExpr`` and that is how the comms with Z3 are
showing up while I'm tracing. To work on this I added simple-smt as a submodule
after first forking it to the *BlockScope* organization on github.

.. code:: pre

    > git submodule add https://github.com/BlockScope/simple-smt
    > cd simple-smt
    > git checkout -b wip/plugins-for-blobs

I need to add an entry to ``cabal.project`` to pick up this dependency locally
rather than from hackage, all without changing any of the ``*.cabal`` files that
mention ``simple-smt`` as a dependency.

.. code:: haskell

    -- cabal.project
    packages:
        simple-smt
        thoralf-plugin

By passing an ``SExpr -> ShowsS`` printer in as a parameter when setting up the
solver and using this instead of ``showsSExpr`` I'm now getting nicely formatted
and much easier to follow tracing. As a bonus, lines are all short enough so hat
they won't need scrolling when viewed in a narrow frame so as when showing up as
code snippets on this blog.

.. code:: haskell

    -- | Start a new solver process.
    newSolver
        :: String -- ^ Executable
        -> [String] -- ^ Arguments
        -> (SExpr -> ShowS) -- ^ Function for showing s-expressions
        -> Maybe Logger -- ^ Optional logging here
        -> IO Solver

Roundtripping
-------------

I'd like to be able to take the output of tracing compilation of a package with
modules using the thoralf plugin and then to take that output and use it as
input to the Z3 solver as-is.

The logging of simple-smt prefixes comms with ``[send->]`` and ``[<-recv]``. I'm
able to filter that out before tracing by updating the logger to strip out those
prefixes.

.. code:: haskell

    data DebugSmtTalk =
        DebugSmtTalk
            { traceSend :: Bool
            , traceRecv :: DebugSmtRecv
            , traceErr :: Bool
            , traceOther :: Bool
            , traceArrow :: Bool
            , traceCtsComments :: Bool
            }

    data DebugSmtRecv
        = DebugSmtRecvAll Bool
        | DebugSmtRecvSome
            { traceSuccess :: Bool
            , traceCheckSat :: Bool
            }
        deriving Eq

    -- | Flag for controlling the two-way conversation with the SMT solver.
    newtype TraceSmtTalk = TraceSmtTalk DebugSmtTalk

    -- TODO: Contribute upstream to SimpleSMT to avoid matching on string prefixes.
    solverWithLevel :: TraceSmtTalk -> IO SMT.Solver
    solverWithLevel (TraceSmtTalk dbg)
        | isSilencedTalk dbg = grabSMTsolver Nothing
        | otherwise = do
            logger@Logger{logMessage = logMsg} <- SMT.newLogger 0
            let logger' = logger{logMessage = \s -> do
                let sends = split (dropBlanks $ onSublist "[send->] ") s
                let recvs = split (dropBlanks $ onSublist "[<-recv] ") s
                let errs = split (dropBlanks $ onSublist "[stderr] ") s

                let dbgArrow = traceArrow dbg
                let dbgSend = traceSend dbg

                let dbgRecvCheckSat =
                        case traceRecv dbg of
                            DebugSmtRecvSome{traceCheckSat = b} -> b
                            _ -> False

                let dbgRecvSuccess =
                        case traceRecv dbg of
                            DebugSmtRecvSome{traceSuccess = b} -> b
                            _ -> False

                let dbgRecvAll = DebugSmtRecvAll True == traceRecv dbg

                case (recvs, sends, errs) of
                    (_, "[send->] " : [msg], _) ->
                        if | dbgSend && dbgArrow -> logMsg s
                           | dbgSend -> logMsg msg
                           | otherwise -> return ()

                    -- NOTE: :print-success can print success | unsupported | error _.
                    ("[<-recv] " : msgContent, _, _) ->
                        case msgContent of
                            [msg@"sat"] ->
                                if | dbgRecvCheckSat && dbgArrow -> logMsg s
                                   | dbgRecvCheckSat -> logMsg msg
                                   | otherwise -> return ()

                            [msg@"unsat"] ->
                                if | dbgRecvCheckSat && dbgArrow -> logMsg s
                                   | dbgRecvCheckSat -> logMsg msg
                                   | otherwise -> return ()

                            [msg@"success"] ->
                                if | dbgRecvSuccess && dbgArrow -> logMsg s
                                   | dbgRecvSuccess -> logMsg msg
                                   | otherwise -> return ()

                            [msg@"unsupported"] ->
                                if | dbgRecvSuccess && dbgArrow -> logMsg s
                                   | dbgRecvSuccess -> logMsg msg
                                   | otherwise -> return ()

                            "error" : _ ->
                                if | dbgRecvSuccess && dbgArrow -> logMsg s
                                   | dbgRecvSuccess -> logMsg $ drop (length "[<-recv] error ") s
                                   | otherwise -> return ()

                            _msgs ->
                                if | dbgRecvAll && dbgArrow -> logMsg s
                                   | dbgRecvAll -> logMsg s
                                   | otherwise -> return ()

                    (_, _, "[stderr] " : _) ->
                        when (traceErr dbg) $ logMsg s

                    (_, _, _) ->
                        when (traceOther dbg) $ logMsg s
                }

            grabSMTsolver (Just logger')

    grabSMTsolver :: Maybe SMT.Logger -> IO SMT.Solver
    grabSMTsolver =
        -- NOTE: IfÂ you don't want the s-expressions pretty printed then substitute
        -- SMT.showsSExpr for SMT.ppSExpr.
        SMT.newSolver "z3" ["-smt2", "-in"] SMT.ppSExpr

What's left to do for roundtripping is prefix any output that I don't want as
input with ``;`` to make it a comment.

.. _simple-smt: https://hackage.haskell.org/package/simple-smt
.. _smt-lib: https://smtlib.cs.uiowa.edu/language.shtml